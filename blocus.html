<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>        .context-menu {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }        .game-ui {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #333;
            font-family: Arial, sans-serif;
            z-index: 2000;
            min-width: 200px;
            max-width: 250px;
        }

        .score-display {
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
        }

        .player-turn {
            margin-bottom: 10px;
            font-size: 16px;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
        }

        .mode-controls {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ccc;
        }

        .mode-button {
            display: inline-block;
            margin: 2px;
            padding: 5px 10px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .mode-button.active {
            background: #4CAF50;
            color: white;
        }

        .dev-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ccc;
        }

        .debug-line {
            stroke-width: 6px;
            opacity: 0.8;
            z-index: 100;
        }

        .debug-step {
            animation: debugPulse 1s ease-in-out;
        }

        @keyframes debugPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
    </style>
</head>

<body>
    <div id="contextMenu" class="context-menu"></div>
    
    <!-- Interface de jeu -->
    <div id="gameUI" class="game-ui">
        <div class="score-display">
            <div>Joueur 1: <span id="player1Score">0</span> points</div>
            <div>Joueur 2: <span id="player2Score">0</span> points</div>
        </div>
        <div id="playerTurn" class="player-turn">Tour du Joueur 1</div>
        
        <div class="mode-controls">
            <div>Mode:</div>
            <div id="simpleMode" class="mode-button active" onclick="setGameMode('simple')">Simple</div>
            <div id="devMode" class="mode-button" onclick="setGameMode('dev')">D√©veloppeur</div>
        </div>
        
        <div id="devControls" class="dev-controls" style="display: none;">
            <button onclick="runEnclosureTests()">Tests Enclosure</button>
            <button onclick="runQuickCaptureTest()">Test Capture</button>
            <button onclick="clearBoard()">Clear Board</button>            <div>
                <label>Vitesse debug: </label>
                <input type="range" id="debugSpeed" min="100" max="3000" value="1000" 
                       onchange="updateDebugSpeed(this.value)">
                <span id="speedValue">1000ms</span>
            </div>
        </div>
    </div>
    <script language="javascript">
        const caseSize = 50; // Taille d'une case en pixels
        const circleSize = 30; // Taille d'un cercle en pixels
        const backgroundColor = '#BCD8C1'; // Couleur de fond des cases
        const player1Color = '#00b4d8'; // Couleur du joueur 1
        const player2Color = '#ff8fab'; // Couleur du joueur 2        const gridlength = 15; // Taille de la grille
        let cases = []; // Tableau 2D pour stocker les cases
        let realLines = []; // Tableau pour stocker les lignes r√©elles
        let virtualLines = []; // Tableau pour stocker les lignes virtuelles
        let player = 1; // Variable globale pour le joueur actif
        let currentLoopPlayer = 0; // Store the player who formed the loop being checked
        let gridlength = 15; // Taille de la grille

        // Syst√®me de points
        let player1Score = 0;
        let player2Score = 0;
        
        // Syst√®me de modes
        let devMode = false;
        let debugStepDelay = 1000; // D√©lai en ms pour le mode dev
        let currentDebugStep = 0;

        // --- Case Class (version unique) ---
        class Case {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 50;
                this.player = 0;
                this.id = 'case' + this.x + "_" + this.y;
                this.canHaveLine = true;
                this.isCaptured = false;
            }

            create() {
                var div = document.createElement('div');
                div.style.width = '50px';
                div.style.height = '50px';
                div.style.backgroundColor = backgroundColor;
                div.style.position = 'absolute';
                div.style.left = this.x * caseSize + 'px';
                div.style.top = this.y * caseSize + 'px';
                div.style.border = '1px solid black';
                div.id = this.id;
                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const menu = document.getElementById('contextMenu');
                    menu.style.display = 'block';
                    menu.style.left = e.pageX + 'px';
                    menu.style.top = e.pageY + 'px';
                    menu.innerHTML = `
                        <div>Position: (${this.x}, ${this.y})</div>
                        <div>Joueur: ${this.player}</div>
                        <div>ID: ${this.id}</div>
                        <div>Captur√©: ${this.isCaptured}</div>
                    `;
                });
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.context-menu')) {
                        const menu = document.getElementById('contextMenu');
                        if (menu) menu.style.display = 'none';
                    }
                });

                div.onclick = () => {
                    if (this.player === 0 && !this.isCaptured) {
                        this.draw(player);
                    }
                };

                document.body.appendChild(div);
            }            draw(currentPlayer) {
                // V√©rifier si la case est libre ET pas dans une zone captur√©e
                if (this.player != 0 || this.isCaptured || this.isInCapturedArea()) {
                    console.log(`Placement impossible sur (${this.x}, ${this.y}) - Case occup√©e ou dans zone captur√©e`);
                    return;
                }

                var cell = document.getElementById(this.id);
                var circle = document.createElement('div');
                circle.style.width = circleSize + 'px';
                circle.style.height = circleSize + 'px';
                circle.style.borderRadius = '50%';
                circle.style.position = 'absolute';
                circle.id = 'circle' + this.x + "_" + this.y;

                var diff = (caseSize - circleSize) / 2;
                circle.style.left = diff + 'px';
                circle.style.top = diff + 'px';

                if (currentPlayer == 1) {
                    this.player = 1;
                    circle.style.backgroundColor = player1Color;
                    player = 2;
                } else if (currentPlayer == 2) {
                    this.player = 2;
                    circle.style.backgroundColor = player2Color;
                    player = 1;
                }
                cell.appendChild(circle);

                setTimeout(() => {
                    detectAndProcessLoops(this);
                }, 0);
            }

            // V√©rifie si cette case est dans une zone d√©j√† encercl√©e par des lignes r√©elles
            isInCapturedArea() {
                if (realLines.length === 0) return false;
                
                // Cr√©er des groupes de lignes connect√©es pour former des polygones ferm√©s
                const polygons = this.findClosedPolygons();
                
                for (const polygon of polygons) {
                    if (PolygonUtils.isPointInPolygon(this, polygon)) {
                        return true;
                    }
                }
                return false;
            }

            // Trouve tous les polygones ferm√©s form√©s par les lignes r√©elles
            findClosedPolygons() {
                const polygons = [];
                const usedLines = new Set();
                
                for (const startLine of realLines) {
                    if (usedLines.has(startLine.id)) continue;
                    
                    const polygon = this.tracePolygon(startLine, usedLines);
                    if (polygon && polygon.length >= 3) {
                        polygons.push(polygon);
                    }
                }
                
                return polygons;
            }

            // Trace un polygone √† partir d'une ligne de d√©part
            tracePolygon(startLine, usedLines) {
                if (usedLines.has(startLine.id)) return null;
                
                const polygon = [startLine.case1, startLine.case2];
                usedLines.add(startLine.id);
                let currentCase = startLine.case2;
                
                while (true) {
                    let nextLine = null;
                    
                    // Chercher une ligne connect√©e qui n'a pas √©t√© utilis√©e
                    for (const line of realLines) {
                        if (usedLines.has(line.id)) continue;
                        
                        if (line.case1.id === currentCase.id) {
                            nextLine = line;
                            currentCase = line.case2;
                            break;
                        } else if (line.case2.id === currentCase.id) {
                            nextLine = line;
                            currentCase = line.case1;
                            break;
                        }
                    }
                    
                    if (!nextLine) break;
                    
                    // Si on revient au point de d√©part, le polygone est ferm√©
                    if (currentCase.id === startLine.case1.id) {
                        usedLines.add(nextLine.id);
                        return polygon;
                    }
                    
                    polygon.push(currentCase);
                    usedLines.add(nextLine.id);
                }
                
                return null; // Polygone non ferm√©
            }

            neighbors(p, once = false) {
                let neighborsList = [];
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [1, -1], [-1, 1], [1, 1]
                ];

                for (const [dx, dy] of directions) {
                    const nx = this.x + dx;
                    const ny = this.y + dy;

                    if (nx >= 0 && nx < gridlength && ny >= 0 && ny < gridlength) {
                        const neighborCase = cases[ny][nx];
                        if (neighborCase.player === p && !neighborCase.isCaptured) {
                            neighborsList.push(neighborCase);
                            if (once) return neighborsList;
                        }
                    }
                }
                return neighborsList;
            }

            capture() {
                this.isCaptured = true;
                this.player = 0;

                var circle = document.getElementById('circle' + this.x + "_" + this.y);
                if (circle) {
                    circle.remove();
                }

                var div = document.getElementById(this.id);
                if (div) {
                    div.style.backgroundColor = '#A0A0A0';
                }

                div.onclick = null;
            }

            reset() {
                this.player = 0;
                this.isCaptured = false;
                this.canHaveLine = true;
                const div = document.getElementById(this.id);
                if (div) {
                    div.style.backgroundColor = backgroundColor;
                    const circle = document.getElementById('circle' + this.x + "_" + this.y);
                    if (circle) circle.remove();
                    div.onclick = () => {
                        if (this.player === 0 && !this.isCaptured) {
                            this.draw(player);
                        }
                    };
                }
            }
        }

        // --- Line Class (version unique) ---
        class Line {
            constructor(case1, case2, real) {
                if (case1.id > case2.id) { [case1, case2] = [case2, case1]; }

                this.case1 = case1;
                this.case2 = case2;
                this.real = real;
                this.id = 'line_' + this.case1.x + '_' + this.case1.y + '_' + this.case2.x + '_' + this.case2.y;

                const targetArray = real ? realLines : virtualLines;
                if (Line.lineExists(this.case1, this.case2, targetArray)) {
                    return null;
                }
                targetArray.push(this);
            }

            static lineExists(case1, case2, array) {
                if (case1.id > case2.id) { [case1, case2] = [case2, case1]; }
                const idToCheck = 'line_' + case1.x + '_' + case1.y + '_' + case2.x + '_' + case2.y;
                return array.some(line => line.id === idToCheck);
            }

            getCenterCoords(c) {
                return {
                    x: c.x * caseSize + caseSize / 2,
                    y: c.y * caseSize + caseSize / 2
                };
            }

            create() {
                if (document.getElementById(this.id)) {
                    const element = document.getElementById(this.id);
                    element.style.opacity = this.real ? '1' : '0.4';
                    element.style.backgroundColor = this.case1.player == 1 ? player1Color : player2Color;
                    element.style.zIndex = this.real ? '50' : '40';
                    return;
                }

                const line = document.createElement('div');
                line.style.position = 'absolute';
                line.style.height = '4px';
                line.style.backgroundColor = this.case1.player == 1 ? player1Color : player2Color;
                line.style.borderRadius = '2px';
                line.style.opacity = this.real ? '1' : '0.4';
                line.style.zIndex = this.real ? '50' : '40';
                line.id = this.id;

                line.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const menu = document.getElementById('contextMenu');
                    menu.style.display = 'block';
                    menu.style.left = e.pageX + 'px';
                    menu.style.top = e.pageY + 'px';
                    menu.innerHTML = `
                        <div>Line: ${this.id}</div>
                        <div>Case1: (${this.case1.x}, ${this.case1.y}) Player ${this.case1.player}</div>
                        <div>Case2: (${this.case2.x}, ${this.case2.y}) Player ${this.case2.player}</div>
                        <div>Real: ${this.real}</div>
                    `;
                });

                const p1 = this.getCenterCoords(this.case1);
                const p2 = this.getCenterCoords(this.case2);

                const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;

                line.style.width = length + 'px';
                line.style.left = p1.x + 'px';
                line.style.top = p1.y - 2 + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                line.style.transformOrigin = '0 50%';

                document.body.appendChild(line);
            }

            remove() {
                const element = document.getElementById(this.id);
                if (element) {
                    element.remove();
                }

                let index = realLines.findIndex(l => l.id === this.id);
                if (index > -1) {
                    realLines.splice(index, 1);
                } else {
                    index = virtualLines.findIndex(l => l.id === this.id);
                    if (index > -1) {
                        virtualLines.splice(index, 1);
                    }
                }
                this.case1 = null;
                this.case2 = null;
            }

            static removeAllVirtual() {
                for (let i = virtualLines.length - 1; i >= 0; i--) {
                    virtualLines[i].remove();
                }
                virtualLines = [];
            }

            static removeAllReal() {
                for (let i = realLines.length - 1; i >= 0; i--) {
                    realLines[i].remove();
                }
                realLines = [];
            }            makeReal() {
                if (this.real) return;

                // Retirer de virtualLines d'abord
                let index = virtualLines.findIndex(l => l.id === this.id);
                if (index > -1) {
                    virtualLines.splice(index, 1);
                }

                this.real = true;

                // Ajouter √† realLines seulement si pas d√©j√† pr√©sent
                if (!Line.lineExists(this.case1, this.case2, realLines)) {
                    realLines.push(this);
                }

                // Mettre √† jour l'affichage
                const element = document.getElementById(this.id);
                if (element) {
                    element.style.opacity = '1';
                    element.style.zIndex = '50';
                } else {
                    this.create();
                }
                
                console.log(`Ligne rendue r√©elle: ${this.id}`);
            }
        }        // --- NOUVEAU SYST√àME DE CAPTURE AM√âLIOR√â ---

        // Classe utilitaire pour les op√©rations g√©om√©triques
        class PolygonUtils {
            // Algorithme ray-casting am√©lior√© pour d√©terminer si un point est dans un polygone
            static isPointInPolygon(point, polygon) {
                const x = point.x + 0.5;
                const y = point.y + 0.5;
                let inside = false;
                
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x + 0.5;
                    const yi = polygon[i].y + 0.5;
                    const xj = polygon[j].x + 0.5;
                    const yj = polygon[j].y + 0.5;
                    
                    if (((yi > y) !== (yj > y)) && 
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                        inside = !inside;
                    }
                }
                return inside;
            }

            // Calcule l'aire d'un polygone (pour v√©rifier s'il est valide)
            static polygonArea(polygon) {
                let area = 0;
                for (let i = 0; i < polygon.length; i++) {
                    const j = (i + 1) % polygon.length;
                    area += polygon[i].x * polygon[j].y;
                    area -= polygon[j].x * polygon[i].y;
                }
                return Math.abs(area) / 2;
            }
        }

        // Classe pour repr√©senter et analyser les boucles
        class LoopDetector {
            constructor(player) {
                this.player = player;
                this.debugMode = false;
            }            // Trouve toutes les boucles possibles pour un joueur
            async findLoops(startCase) {
                const loops = [];
                const visited = new Set();
                
                await this.dfsForLoops(startCase, [startCase], visited, loops);
                
                if (this.debugMode) {
                    console.log(`Trouv√© ${loops.length} boucles pour le joueur ${this.player}`);
                }
                
                return loops;
            }// Recherche r√©cursive de boucles avec DFS
            async dfsForLoops(currentCase, path, globalVisited, loops) {
                const neighbors = currentCase.neighbors(this.player);
                
                // Visualisation en mode dev
                if (devMode && this.debugMode) {
                    await this.highlightCurrentPath(path);
                    console.log(`üîç [DFS] Exploration depuis (${currentCase.x},${currentCase.y}), chemin: ${path.map(c => `(${c.x},${c.y})`).join(' -> ')}`);
                    
                    // Petit d√©lai pour permettre la visualisation
                    await new Promise(resolve => setTimeout(resolve, debugStepDelay / 8));
                }
                
                for (const neighbor of neighbors) {
                    // Si on revient au point de d√©part et qu'on a au moins 3 cases
                    if (path.length >= 3 && neighbor === path[0]) {
                        const loop = [...path];
                        if (this.isValidLoop(loop)) {
                            loops.push(loop);
                            if (this.debugMode) {
                                console.log('üéØ [DFS] Boucle valide trouv√©e:', loop.map(c => `(${c.x},${c.y})`));
                                if (devMode) {
                                    await this.highlightFoundLoop(loop);
                                }
                            }
                        }
                        continue;
                    }
                    
                    // √âviter de revisiter des cases dans le m√™me chemin
                    if (path.indexOf(neighbor) === -1) {
                        const newPath = [...path, neighbor];
                        await this.dfsForLoops(neighbor, newPath, globalVisited, loops);
                    }
                }
                
                // Nettoyer la visualisation
                if (devMode && this.debugMode) {
                    await this.clearPathHighlight(path);
                }
            }

            // Visualise le chemin actuel en mode dev
            async highlightCurrentPath(path) {
                if (!devMode || path.length < 2) return;
                
                for (let i = 0; i < path.length - 1; i++) {
                    const line = document.createElement('div');
                    line.className = 'debug-path-line';
                    line.style.position = 'absolute';
                    line.style.height = '6px';
                    line.style.backgroundColor = '#FFD700'; // Couleur dor√©e pour exploration
                    line.style.opacity = '0.7';
                    line.style.zIndex = '999';
                    line.style.borderRadius = '3px';
                    
                    const p1 = {
                        x: path[i].x * caseSize + caseSize / 2,
                        y: path[i].y * caseSize + caseSize / 2
                    };
                    const p2 = {
                        x: path[i + 1].x * caseSize + caseSize / 2,
                        y: path[i + 1].y * caseSize + caseSize / 2
                    };
                    
                    const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = p1.x + 'px';
                    line.style.top = p1.y - 3 + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.transformOrigin = '0 50%';
                    line.id = `debug-path-${path[i].x}-${path[i].y}-${path[i + 1].x}-${path[i + 1].y}`;
                    
                    document.body.appendChild(line);
                }
                
                await new Promise(resolve => setTimeout(resolve, debugStepDelay / 4));
            }

            // Met en √©vidence une boucle trouv√©e
            async highlightFoundLoop(loop) {
                if (!devMode) return;
                
                for (let i = 0; i < loop.length; i++) {
                    const c1 = loop[i];
                    const c2 = loop[(i + 1) % loop.length];
                    
                    const line = document.createElement('div');
                    line.className = 'debug-loop-line';
                    line.style.position = 'absolute';
                    line.style.height = '8px';
                    line.style.backgroundColor = '#FF6B6B'; // Rouge pour boucle trouv√©e
                    line.style.opacity = '0.9';
                    line.style.zIndex = '998';
                    line.style.borderRadius = '4px';
                    line.style.boxShadow = '0 0 10px rgba(255, 107, 107, 0.5)';
                    
                    const p1 = {
                        x: c1.x * caseSize + caseSize / 2,
                        y: c1.y * caseSize + caseSize / 2
                    };
                    const p2 = {
                        x: c2.x * caseSize + caseSize / 2,
                        y: c2.y * caseSize + caseSize / 2
                    };
                    
                    const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = p1.x + 'px';
                    line.style.top = p1.y - 4 + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.transformOrigin = '0 50%';
                    line.id = `debug-loop-${c1.x}-${c1.y}-${c2.x}-${c2.y}`;
                    
                    document.body.appendChild(line);
                }
                
                await new Promise(resolve => setTimeout(resolve, debugStepDelay));
                
                // Supprimer les lignes de debug apr√®s visualisation
                document.querySelectorAll('.debug-loop-line').forEach(el => el.remove());
            }

            // Nettoie les visualisations du chemin
            async clearPathHighlight(path) {
                if (!devMode || path.length < 2) return;
                
                for (let i = 0; i < path.length - 1; i++) {
                    const id = `debug-path-${path[i].x}-${path[i].y}-${path[i + 1].x}-${path[i + 1].y}`;
                    const element = document.getElementById(id);
                    if (element) {
                        element.remove();
                    }
                }
            }

            // V√©rifie si une boucle est valide
            isValidLoop(loop) {
                if (loop.length < 3) return false;
                
                // V√©rifier que la boucle forme un polygone ferm√©
                const area = PolygonUtils.polygonArea(loop);
                return area > 0.5; // Aire minimale pour √©viter les boucles d√©g√©n√©r√©es
            }

            // Trouve la meilleure boucle (plus grande aire avec des captures)
            findBestLoop(loops) {
                let bestLoop = null;
                let maxScore = 0;
                
                for (const loop of loops) {
                    const capturedCount = this.countCapturedPieces(loop);
                    const area = PolygonUtils.polygonArea(loop);
                    const score = capturedCount * 10 + area; // Priorit√© aux captures
                    
                    if (score > maxScore) {
                        maxScore = score;
                        bestLoop = loop;
                    }
                }
                
                return bestLoop;
            }

            // Compte les pi√®ces adverses qui seraient captur√©es
            countCapturedPieces(loop) {
                let count = 0;
                const enemyPlayer = this.player === 1 ? 2 : 1;
                
                for (let y = 0; y < gridlength; y++) {
                    for (let x = 0; x < gridlength; x++) {
                        const c = cases[y][x];
                        if (c.player === enemyPlayer && !c.isCaptured) {
                            if (PolygonUtils.isPointInPolygon(c, loop)) {
                                count++;
                            }
                        }
                    }
                }
                
                return count;
            }            // Ex√©cute la capture pour une boucle donn√©e
            executeCapture(loop) {
                if (!loop) return false;
                
                let capturedAny = false;
                let pointsEarned = 0;
                const enemyPlayer = this.player === 1 ? 2 : 1;
                
                // Trouver les cases √† capturer dans la boucle
                const casesToCapture = [];
                const enemyCasesInLoop = [];
                
                for (let y = 0; y < gridlength; y++) {
                    for (let x = 0; x < gridlength; x++) {
                        const c = cases[y][x];
                        if (PolygonUtils.isPointInPolygon(c, loop)) {
                            // NE PAS capturer les pions du joueur qui a form√© la boucle
                            if (c.player !== this.player) {
                                casesToCapture.push(c);
                                
                                // Compter seulement les pions adverses pour les points
                                if (c.player === enemyPlayer && !c.isCaptured) {
                                    enemyCasesInLoop.push(c);
                                    pointsEarned++;
                                }
                            }
                        }
                    }
                }
                
                if (casesToCapture.length > 0) {
                    // Il y a des cases √† capturer : cr√©er les lignes r√©elles
                    this.createLoopLines(loop, true);
                    
                    // Capturer seulement les cases ennemies et vides
                    for (const caseToCapture of casesToCapture) {
                        if (!caseToCapture.isCaptured) {
                            caseToCapture.capture();
                            capturedAny = true;
                            if (this.debugMode) {
                                const type = caseToCapture.player === 0 ? "vide" : 
                                           caseToCapture.player === enemyPlayer ? "ennemi" : "neutre";
                                console.log(`Captur√© case ${type}: (${caseToCapture.x}, ${caseToCapture.y})`);
                            }
                        }
                    }
                    
                    // Ajouter les points au score
                    if (pointsEarned > 0) {
                        if (this.player === 1) {
                            player1Score += pointsEarned;
                        } else {
                            player2Score += pointsEarned;
                        }
                        updateScoreDisplay();
                    }
                    
                    console.log(`Capture r√©ussie! ${casesToCapture.length} cases captur√©es, ${pointsEarned} points gagn√©s.`);
                } else {
                    // Pas de captures : cr√©er des lignes virtuelles temporaires
                    this.createLoopLines(loop, false);
                    setTimeout(() => {
                        Line.removeAllVirtual();
                    }, 2000);
                    console.log('Boucle form√©e mais aucune case √† capturer.');
                }
                
                return capturedAny;
            }// Cr√©e les lignes visuelles pour une boucle
            createLoopLines(loop, makeReal = false) {
                const lines = [];
                
                for (let i = 0; i < loop.length; i++) {
                    const c1 = loop[i];
                    const c2 = loop[(i + 1) % loop.length];
                    
                    // V√©rifier si la ligne existe d√©j√†
                    const targetArray = makeReal ? realLines : virtualLines;
                    
                    if (!Line.lineExists(c1, c2, targetArray)) {
                        const line = new Line(c1, c2, makeReal);
                        if (line) {
                            line.create();
                            lines.push(line);
                        }
                    } else {
                        // Si la ligne existe d√©j√† et qu'on veut la rendre r√©elle
                        if (makeReal) {
                            const existingLine = targetArray.find(l => 
                                (l.case1.id === c1.id && l.case2.id === c2.id) ||
                                (l.case1.id === c2.id && l.case2.id === c1.id)
                            );
                            if (existingLine && !existingLine.real) {
                                existingLine.makeReal();
                                lines.push(existingLine);
                            }
                        }
                    }
                }
                
                return lines;
            }
        }        // Fonction principale de d√©tection et traitement des boucles
        async function detectAndProcessLoops(lastCase) {
            Line.removeAllVirtual(); // Nettoyer les lignes virtuelles
            
            const detector = new LoopDetector(lastCase.player);
            detector.debugMode = devMode; // Utiliser le mode dev global
            
            if (devMode) {
                console.log(`üîç [DEV] D√©but d√©tection de boucles pour le joueur ${lastCase.player}`);
                console.log(`üîç [DEV] Position de d√©part: (${lastCase.x}, ${lastCase.y})`);
            }
            
            // Trouver toutes les boucles possibles (async)
            const loops = await detector.findLoops(lastCase);
            
            if (loops.length === 0) {
                if (devMode) {
                    console.log('‚ùå [DEV] Aucune boucle d√©tect√©e');
                }
                return;
            }
            
            if (devMode) {
                console.log(`‚úÖ [DEV] ${loops.length} boucle(s) trouv√©e(s)`);
                for (let i = 0; i < loops.length; i++) {
                    console.log(`   Boucle ${i+1}: ${loops[i].map(c => `(${c.x},${c.y})`).join(' -> ')}`);
                }
            }
            
            // Trouver la meilleure boucle
            const bestLoop = detector.findBestLoop(loops);
            
            if (bestLoop) {
                if (devMode) {
                    console.log('üéØ [DEV] Meilleure boucle s√©lectionn√©e:', bestLoop.map(c => `(${c.x},${c.y})`));
                    console.log('üéØ [DEV] Ex√©cution de la capture...');
                }
                detector.executeCapture(bestLoop);
            }
        }

        // Fonction utilitaire pour les tests - algorithme ray-casting simple
        function isPointInsideLoop(point, loopLines) {
            const x = point.x + 0.5;
            const y = point.y + 0.5;
            let intersections = 0;
            
            for (let line of loopLines) {
                let x1 = line.case1.x + 0.5;
                let y1 = line.case1.y + 0.5;
                let x2 = line.case2.x + 0.5;
                let y2 = line.case2.y + 0.5;
                
                // Ignore les segments horizontaux
                if (y1 === y2) continue;
                
                // V√©rifie si le segment croise la ligne horizontale y
                if ((y >= Math.min(y1, y2)) && (y < Math.max(y1, y2))) {
                    let intersectX = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
                    if (intersectX > x) intersections++;
                }
            }
            return intersections % 2 === 1;
        }

        // Fonctions de gestion des modes
        function setGameMode(mode) {
            devMode = (mode === 'dev');
            
            // Mettre √† jour l'interface
            document.getElementById('simpleMode').classList.toggle('active', !devMode);
            document.getElementById('devMode').classList.toggle('active', devMode);
            document.getElementById('devControls').style.display = devMode ? 'block' : 'none';
            
            console.log(`Mode chang√© vers: ${mode}`);
            
            if (devMode) {
                console.log('üîß [DEV] Mode d√©veloppeur activ√©');
                console.log('üîß [DEV] Fonctionnalit√©s disponibles:');
                console.log('   - Tests automatiques');
                console.log('   - Logs d√©taill√©s des algorithmes');
                console.log('   - Vitesse de debug ajustable');
                console.log('   - Visualisations sp√©ciales');
            } else {
                console.log('üéÆ Mode simple activ√© - Interface √©pur√©e');
            }
        }

        function updateDebugSpeed(value) {
            debugStepDelay = parseInt(value);
            document.getElementById('speedValue').textContent = value + 'ms';
            console.log(`Vitesse de debug mise √† jour: ${value}ms`);
        }

        function updateScoreDisplay() {
            document.getElementById('player1Score').textContent = player1Score;
            document.getElementById('player2Score').textContent = player2Score;
            
            // Mettre √† jour l'affichage du tour
            const turnDisplay = document.getElementById('playerTurn');
            turnDisplay.textContent = `Tour du Joueur ${player}`;
            turnDisplay.style.backgroundColor = player === 1 ? '#e3f2fd' : '#fce4ec';
            turnDisplay.style.color = player === 1 ? '#1976d2' : '#c2185b';
        }

        function createGrid() {
            const container = document.createElement('div');
            container.style.position = 'relative';
            container.style.width = (gridlength * caseSize) + 'px';
            container.style.height = (gridlength * caseSize) + 'px';
            container.id = 'grid-container';
            document.body.appendChild(container);

            cases = [];
            for (let y = 0; y < gridlength; y++) {
                cases[y] = [];
                for (let x = 0; x < gridlength; x++) {
                    cases[y][x] = new Case(x, y);
                    cases[y][x].create();
                }
            }
        }        window.onload = function () {
            createGrid();
            setupTestButton();
            updateScoreDisplay(); // Initialiser l'affichage des scores
        }        
        function setupTestButton() {
            const testButton = document.createElement('button');
            testButton.textContent = 'Run Enclosure Tests';
            testButton.style.position = 'fixed';
            testButton.style.top = '300px';
            testButton.style.right = '10px';
            testButton.style.zIndex = '2000';
            testButton.onclick = runEnclosureTests;
            document.body.appendChild(testButton);

            const clearButton = document.createElement('button');
            clearButton.textContent = 'Clear Board';
            clearButton.style.position = 'fixed';
            clearButton.style.top = '330px';
            clearButton.style.right = '10px';
            clearButton.style.zIndex = '2000';
            clearButton.onclick = clearBoard;
            document.body.appendChild(clearButton);

            const quickTestButton = document.createElement('button');
            quickTestButton.textContent = 'Quick Test Capture';
            quickTestButton.style.position = 'fixed';
            quickTestButton.style.top = '360px';
            quickTestButton.style.right = '10px';
            quickTestButton.style.zIndex = '2000';            quickTestButton.onclick = runQuickCaptureTest;
            document.body.appendChild(quickTestButton);
        }

        function clearBoard() {
            Line.removeAllReal();
            Line.removeAllVirtual();
            for (let y = 0; y < gridlength; y++) {
                for (let x = 0; x < gridlength; x++) {
                    if (cases[y] && cases[y][x]) {
                        cases[y][x].reset();
                    }
                }
            }
            player = 1;
            player1Score = 0;
            player2Score = 0;
            updateScoreDisplay();
            
            // Nettoyer les visualisations debug
            document.querySelectorAll('.debug-path-line, .debug-loop-line').forEach(el => el.remove());
            
            console.log("Board cleared, scores reset.");
        }        function runQuickCaptureTest() {
            clearBoard();
            
            console.log("=== Test Rapide de Capture ===");
            
            // Cr√©er un carr√© avec le joueur 1
            const corner1 = cases[2][2];
            const corner2 = cases[2][4];
            const corner3 = cases[4][4];
            const corner4 = cases[4][2];
            
            corner1.player = 1;
            corner2.player = 1;
            corner3.player = 1;
            corner4.player = 1;
            
            // Cr√©er les cercles visuels
            [corner1, corner2, corner3, corner4].forEach(c => {
                const circle = document.createElement('div');
                circle.style.width = circleSize + 'px';
                circle.style.height = circleSize + 'px';
                circle.style.borderRadius = '50%';
                circle.style.position = 'absolute';
                circle.style.backgroundColor = player1Color;
                circle.id = 'circle' + c.x + "_" + c.y;
                
                const diff = (caseSize - circleSize) / 2;
                circle.style.left = diff + 'px';
                circle.style.top = diff + 'px';
                
                document.getElementById(c.id).appendChild(circle);
            });
            
            // Ajouter un pion joueur 2 √† l'int√©rieur
            const enemyPiece = cases[3][3];
            enemyPiece.player = 2;
            const enemyCircle = document.createElement('div');
            enemyCircle.style.width = circleSize + 'px';
            enemyCircle.style.height = circleSize + 'px';
            enemyCircle.style.borderRadius = '50%';
            enemyCircle.style.position = 'absolute';
            enemyCircle.style.backgroundColor = player2Color;
            enemyCircle.id = 'circle' + enemyPiece.x + "_" + enemyPiece.y;
            
            const diff = (caseSize - circleSize) / 2;
            enemyCircle.style.left = diff + 'px';
            enemyCircle.style.top = diff + 'px';
            
            document.getElementById(enemyPiece.id).appendChild(enemyCircle);
            
            console.log("Configuration test cr√©√©e : carr√© J1 avec pion J2 au centre");
            console.log("Lignes r√©elles avant:", realLines.length);
            console.log("Pion J2 captur√©:", enemyPiece.isCaptured);
            console.log("Score J1 avant:", player1Score);
            
            // Tester la d√©tection de capture
            setTimeout(() => {
                console.log("üîÑ D√©clenchement de la d√©tection de boucles...");
                detectAndProcessLoops(corner1);
                
                setTimeout(() => {
                    console.log("‚úÖ R√©sultats apr√®s d√©tection:");
                    console.log("Lignes r√©elles:", realLines.length);
                    console.log("Pion J2 captur√©:", enemyPiece.isCaptured);
                    console.log("Score J1 apr√®s:", player1Score);
                }, 1000);
            }, 500);
        }

        function runEnclosureTests() {
            console.log("--- Running Enclosure Tests ---");
            let testsPassed = 0;
            let testsFailed = 0;

            const resetTestState = () => {
                clearBoard();
                virtualLines = [];
                realLines = [];
            };

            const assert = (condition, message) => {
                if (condition) {
                    testsPassed++;
                    console.log(`%c  PASS: ${message}`, "color: green");
                } else {
                    testsFailed++;
                    console.error(`%c  FAIL: ${message}`, "color: red; font-weight: bold;");
                }
                return condition;
            };

            resetTestState();
            console.log("\nTest 1: Simple 2x2 Square Loop (Player 1 loop, P2 inside)");
            try {
                const c11 = cases[1][1]; c11.player = 1;
                const c13 = cases[1][3]; c13.player = 1;
                const c33 = cases[3][3]; c33.player = 1;
                const c31 = cases[3][1]; c31.player = 1;
                const p2_target = cases[2][2]; p2_target.player = 2;
                const p1_outside = cases[0][0]; p1_outside.player = 1;
                const p2_outside = cases[4][4]; p2_outside.player = 2;

                const testLoopLines = [
                    new Line(c11, c13, false),
                    new Line(c13, c33, false),
                    new Line(c33, c31, false),
                    new Line(c31, c11, false)
                ].filter(l => l !== null);

                assert(testLoopLines.length === 4, "Test 1: Loop lines created");

                const isInside = isPointInsideLoop(p2_target, testLoopLines);
                assert(isInside, `Test 1: P2 at (${p2_target.x},${p2_target.y}) should be inside`);

                const isOutside1 = isPointInsideLoop(p1_outside, testLoopLines);
                assert(!isOutside1, `Test 1: P1 at (${p1_outside.x},${p1_outside.y}) should be outside`);

                const isOutside2 = isPointInsideLoop(p2_outside, testLoopLines);
                assert(!isOutside2, `Test 1: P2 at (${p2_outside.x},${p2_outside.y}) should be outside`);

                const p_on_line = cases[1][2]; p_on_line.player = 2;
                const isOnLine = isPointInsideLoop(p_on_line, testLoopLines);
                assert(!isOnLine, `Test 1: Point on line (${p_on_line.x},${p_on_line.y}) should be outside`);

            } catch (e) {
                console.error("Error during Test 1:", e);
                testsFailed++;
            }
            Line.removeAllVirtual();

            resetTestState();
            console.log("\nTest 2: Loop touching top boundary");
            try {
                const c01 = cases[0][1]; c01.player = 1;
                const c03 = cases[0][3]; c03.player = 1;
                const c23 = cases[2][3]; c23.player = 1;
                const c21 = cases[2][1]; c21.player = 1;
                const p2_target = cases[1][2]; p2_target.player = 2;
                const p2_outside = cases[3][2]; p2_outside.player = 2;

                const testLoopLines = [
                    new Line(c01, c03, false),
                    new Line(c03, c23, false),
                    new Line(c23, c21, false),
                    new Line(c21, c01, false)
                ].filter(l => l !== null);

                assert(testLoopLines.length === 4, "Test 2: Loop lines created");
                assert(isPointInsideLoop(p2_target, testLoopLines), `Test 2: P2 at (${p2_target.x},${p2_target.y}) should be inside`);
                assert(!isPointInsideLoop(p2_outside, testLoopLines), `Test 2: P2 at (${p2_outside.x},${p2_outside.y}) should be outside`);
            } catch (e) {
                console.error("Error during Test 2:", e);
                testsFailed++;
            }
            Line.removeAllVirtual();

            resetTestState();
            console.log("\nTest 3: Concave Loop (Pacman shape)");
            try {
                const c11 = cases[1][1]; c11.player = 1;
                const c14 = cases[1][4]; c14.player = 1;
                const c34 = cases[3][4]; c34.player = 1;
                const c33 = cases[3][3]; c33.player = 1;
                const c23 = cases[2][3]; c23.player = 1;
                const c22 = cases[2][2]; c22.player = 1;
                const c32 = cases[3][2]; c32.player = 1;
                const c31 = cases[3][1]; c31.player = 1;

                const p2_inside = cases[1][2]; p2_inside.player = 2;
                const p2_outside_indent = cases[2][1]; p2_outside_indent.player = 2;
                const p2_outside_far = cases[4][4]; p2_outside_far.player = 2;

                const testLoopLines = [
                    new Line(c11, c14, false), new Line(c14, c34, false),
                    new Line(c34, c33, false), new Line(c33, c23, false),
                    new Line(c23, c22, false), new Line(c22, c32, false),
                    new Line(c32, c31, false), new Line(c31, c11, false)
                ].filter(l => l !== null);

                assert(testLoopLines.length === 8, "Test 3: Loop lines created");
                assert(isPointInsideLoop(p2_inside, testLoopLines), `Test 3: P2 at (${p2_inside.x},${p2_inside.y}) should be inside`);
                assert(!isPointInsideLoop(p2_outside_indent, testLoopLines), `Test 3: P2 at (${p2_outside_indent.x},${p2_outside_indent.y}) should be outside (indent)`);
                assert(!isPointInsideLoop(p2_outside_far, testLoopLines), `Test 3: P2 at (${p2_outside_far.x},${p2_outside_far.y}) should be outside (far)`);

            } catch (e) {
                console.error("Error during Test 3:", e);
                testsFailed++;
            }
            Line.removeAllVirtual();            resetTestState();
            console.log("\nTest 4: Loop with no opponent stones inside");
            try {
                const c11 = cases[1][1]; c11.player = 1;
                const c13 = cases[1][3]; c13.player = 1;
                const c33 = cases[3][3]; c33.player = 1;
                const c31 = cases[3][1]; c31.player = 1;
                const p2_outside = cases[4][4]; p2_outside.player = 2;

                const detector = new LoopDetector(1);
                detector.debugMode = true;
                const loop = [c11, c13, c33, c31];
                
                const initialVirtualCount = virtualLines.length;
                const result = detector.executeCapture(loop);

                assert(p2_outside.isCaptured === false, "Test 4: Outside stone not captured");
                assert(!result, "Test 4: No capture should occur when no pieces inside");

            } catch (e) {
                console.error("Error during Test 4:", e);
                testsFailed++;
            }
            Line.removeAllVirtual();
            Line.removeAllReal();            resetTestState();
            console.log("\nTest 5: executeCapture causes capture and makes lines real");
            try {
                const c11 = cases[1][1]; c11.player = 1;
                const c13 = cases[1][3]; c13.player = 1;
                const c33 = cases[3][3]; c33.player = 1;
                const c31 = cases[3][1]; c31.player = 1;
                const p2_target = cases[2][2]; p2_target.player = 2;

                // Simuler l'affichage des cases
                [c11, c13, c33, c31].forEach(c => {
                    const circle = document.createElement('div');
                    circle.id = 'circle' + c.x + "_" + c.y;
                    document.getElementById(c.id).appendChild(circle);
                });
                
                const p2Circle = document.createElement('div');
                p2Circle.id = 'circle' + p2_target.x + "_" + p2_target.y;
                document.getElementById(p2_target.id).appendChild(p2Circle);

                const detector = new LoopDetector(1);
                detector.debugMode = true;
                const loop = [c11, c13, c33, c31];
                
                const initialScore1 = player1Score;
                const result = detector.executeCapture(loop);

                assert(p2_target.isCaptured === true, `Test 5: Target stone (${p2_target.x},${p2_target.y}) should be captured`);
                assert(result === true, "Test 5: Capture should return true when successful");
                assert(player1Score === initialScore1 + 1, `Test 5: Player 1 score should increase by 1 (Expected ${initialScore1 + 1}, Got ${player1Score})`);
                assert(realLines.length === 4, `Test 5: Real lines should be 4 after capture (Expected 4, Got ${realLines.length})`);

            } catch (e) {
                console.error("Error during Test 5:", e);
                testsFailed++;
            }
            Line.removeAllVirtual();
            Line.removeAllReal();

            console.log("\n--- Test Summary ---");
            if (testsFailed === 0) {
                console.log(`%cAll ${testsPassed} tests passed!`, "color: green; font-size: 1.2em;");
            } else {
                console.error(`%c${testsPassed} tests passed, ${testsFailed} tests FAILED.`, "color: red; font-size: 1.2em;");
            }
            console.log("--------------------");
        }
    </script>
</body>

</html>